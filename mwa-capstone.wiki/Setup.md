One must have the following:

• The EoRLive project folder

• Vagrant, which is available at https://www.vagrantup.com/. Vagrant is an open-source tool that allows teams to create specific virtual machines, allowing everyone to develop on their own computers but in environments with identical configurations.

Once one has Vagrant installed on his/her machine, then one must do the following with the project folder:

1. Open up the project directory.

2. Navigate to the eorlive_prototype subdirectory.

3. Open Terminal (if on Mac OS X or Linux) or Command Prompt

4. Execute the command vagrant up. This command will take a long time to fully execute. There will be printed a line of the form default: x => x (adapter 1) - the x corresponds to the port number, which is where we will navigate to when loading the website in the browser. As implemented, x = 5000 but may be different in the future.

5. In the web browser, go to the following URL: http://localhost:x/ where x was the port number from earlier.
The commands referred to in this document assume one is inside the /mnt/eorlive_prototype directory of the running Vagrant instance (i.e., the command vagrant ssh has been run).

To start up the Vagrant instance: vagrant up

To shut down the Vagrant instance: vagrant halt

To log into the Vagrant instance: vagrant ssh

The file Vagrantfile is the file that defines the basic configuration of the Vagrant virtual
machine. Here are the important things to note: port 5000 on the VM is mapped to port 5000 on the machine. The eorlive_prototype folder is copied to the VM, but in the VM its location is /mnt/eorlive_prototype.
In provision.sh, which is run automatically the first time one runs the Vagrant instance with vagrant up (in other words, the Vagrant instance is provisioned), there are a few things going on. Firstly, export DATABASE_URL="postgres:///postgres" is written to the ~/.profile file. In Vagrantfile, because privileged is set to false, this shell script is not run as root but as the user vagrant. This line written to the ~/.profile file will therefore be run every time the vagrant user logs in to the VM. This is important because it sets the environment variable DATABASE_URL to the PostgreSQL DB location. SQLAlchemy requires this value to know where the database is in the app.

Also in Vagrantfile, python-virtualenv is installed. This program is used in the command sudo virtualenv --python=/usr/bin/python3.4 flask. virtualenv is a program that allows creation of a “Python virtual environment” in which one can install Python packages. This is important in that the packages installed in this virtual environment do not interfere with other packages that may have been installed on the machine. In this case, the virtual environment is called “flask” (and there is a corresponding folder that is created). The line source flask/bin/activate simply puts us inside the virtual environment, so when we use pip to install the Python packages in the next line, they are installed in the virtual environment.

Then, one creates a vagrant user in the PostgreSQL installation with the line: sudo -u postgres createuser vagrant
since the app is run by the vagrant user and there needs to be a corresponding role in PostgreSQL. The database schema is located in models.py. The schema is just a bunch of Python classes, since SQLAlchemy provides an ORM for one to use. Any time one make changes to the database’s schema (i.e. make changes to the models.py file that should be reflected in the database), one needs to run a migrate command, which has exactly the same syntax as the upgrade command in the provision.sh file. The migrate command generates Python scripts (inside migrations/versions) that will make the necessary changes to the database without having to manually update the database. The necessary files generated by the migrate command are in the migrations/versions folder. It’s necessary to check this folder into version control so that all users have the same database migration scripts.

After migration, the last step is to upgrade the database to match the new schema. To do this, one runs the upgrade command, as shown in provision.sh. If someone else makes a change to the database schema and pushes it to the repository, when one pulls down the changes, all that is needed to do is run the upgrade command. Since the migrations folder is checked into version control, one will have the latest version of the migration scripts, and the upgrade command will apply them automatically.

One can run a Python console and interact with the database through Python commands, as described in:
http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database (the “Play time” section [note that the schema used is different than the one used in the tutorial]). One can insert objects, make queries, etc. to the database efficiently. 

Flask comes with a built-in Web server, which is what is being run when a user enters ./run.py. To access the site, one only needs to navigate to http://127.0.0.1:5000/ in a web browser. The reason the host is 0.0.0.0 in the run.py file is because the Web server is being run on a VM. By default, the VM would use 127.0.0.1 as the host, which is not accessible because it is local to the VM.